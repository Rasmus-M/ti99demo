XAS99 CROSS-ASSEMBLER   VERSION 1.5.3
**** **** ****     > controller.a99
0001               *********************************************************************
0002               * Filename: controller.a99
0003               * Bank:     0
0004               * Date:     05/01/2016
0005               * Author:   orbitaldecay
0006               *
0007               * Control code for the demo. This immediately loads itself to >2000 and
0008               * executes from there. It loads data and code to high memory at >A000 and does
0009               * BL calls to various demo subroutines for screen loading.
0010               *********************************************************************
0011               
0012                      COPY "../common/HEADER.INC"
**** **** ****     > HEADER.INC
0001               *********************************************************************
0002               * Filename: HEADER.INC
0003               * Date:     05/01/2016
0004               * Author:   orbitaldecay
0005               *
0006               * Standard bank header. Needs to be COPYed to the begining of each bank.
0007               * Switches to bank 0 (in the event that we didn't start there). Note: if you
0008               * change the binary size of this header, make sure you update the split command
0009               * in the build script to split files on a (8192 - header size) boundary.
0010               *********************************************************************
0011               
0012               * We use the following register addresses to interact with the VDP
0013               * (Video Display Processor). We first write the low byte of the
0014               * address we want to write at to VDPWA and then write the high byte
0015               * to VDPWA. Then we write the byte we want to write to VDPWD. See
0016               * below for an example. These symbols are defined on page 247 of the
0017               * editor / assembler manual. Usage is described in section 16.4.
0018               
0019      8C02     VDPWA  EQU  >8C02     * Address of VDP RAM write address register
0020      8800     VDPRD  EQU  >8800     * Address of VDP RAM read data register
0021      8C00     VDPWD  EQU  >8C00     * Address of VDP RAM write data register
0022      8802     VDPSTA EQU  >8802     * Address of VDP status register
0023               
0024               * Memory constants
0025               
0026      2000     LMEMSP  EQU >2000    * Pointer to lower memory space
0027      A000     HMEMSP  EQU >A000    * Pointer to upper memory space
0028      6000     CARTSP  EQU >6000    * Pointer to cart space
0029      2000     BANKSZ  EQU >2000    * Bank size (including header)
0030               
0031               * Workspaces and scratchpad stuff
0032               
0033      8300     CTRLWP  EQU  >8300     * Default workspace pointer
0034      8320     SONGWP  EQU  >8320     * Workspace pointer for song playing routine RESERVED
0035      8340     FREEWP  EQU  >8340     * A free workspace
0036      83E0     GPLWP   EQU  >83E0     * Address of GPL workspace (>20 bytes)
0037      8356     FNPNTR  EQU  >8356     * Filename pointer for DSRLNK (>02 bytes)
0038               
0039               * Other memory that is used by stuff
0040               
0041      F000     SONGMEM EQU  >F000     * The currently playing song is located at >F000 - >FFFF
0042      A000     FXMEM   EQU  >A000     * Effect at >A000 to >EFFF avail to use (20K)
0043               
0044               * Reserved for save states. A save state is all 256 bytes of
0045               * scratch pad RAM and the upper >900 bytes of VRAM.
0046               
0047      3000     STATE0  EQU  >3000     * The original state of the machine
0048      3800     STATE1  EQU  >3800     * Temporary save state 1
0049               
0050               
0051               * Cartridge ROM header:
0052               
0053               HEADER
0071               START
0072               
0073               * Bank length (excluding header if present)
0074      2000     BANKLEN EQU BANKSZ - (START - HEADER)
**** **** ****     > controller.a99
0013               
0014               * Addresses used by file loading routines
0015               
0016      3B80     PAB     EQU  >3B80     * PAB address in VDP RAM
0017               
0018               *********************************************************************
0019               * DO NOT CHANGE ANYTHING BELLOW HERE WITHOUT UPDATING THE HARDCODED
0020               * FUNCTION POINTERS IN .\SRC\COMMON\ROUTINES.INC!
0021               *********************************************************************
0022               
0023               * Load workspace pointer for control code
0024 0000 02E0  18        LWPI CTRLWP
     0002 8300 
0025               
0026               * Copy 8K of this bank / file from its current location to lower expansion
0027               * memory then jump to CTRL in lower expansion memory
0028               
0029 0004 0200  20        LI R0,START
     0006 0000r
0030 0008 0201  20        LI R1,LMEMSP
     000A 2000 
0031 000C 0202  20        LI R2,BANKLEN
     000E 2000 
0032 0010 CC70  46 CPLP   MOV *R0+,*R1+
0033 0012 0642  14        DECT R2
0034 0014 16FD  14        JNE CPLP
0035 0016 0460  28        B @CTRL
     0018 2762 
0036               
0037               * Begin control code
0038                      XORG $-START+>2000
0039               
0040               *********************************************************************
0041               * Draw Bitmap
0042               * Switches to graphics mode II and draws a full screen bitmap.
0043               * R1: Bank / file index containing pattern table
0044               * R2: Bank / file index containing color table
0045               * Example:
0046               *
0047               *      LI   R1, 1
0048               *      LI   R2, 2
0049               *      BL   @BITMAP
0050               *
0051               *********************************************************************
0052                      EVEN
0053               BITMAP
0054 001A C80B  38        MOV  R11,@BMR11
     001C 20DC 
0055 001E 02E0  18        LWPI  CTRLWP
     0020 8300 
0056               * Save all the variables we're going to use
0057 0022 C800  38        MOV  R0,@BMR0
     0024 20D4 
0058 0026 C801  38        MOV  R1,@BMR1
     0028 20D6 
0059 002A C802  38        MOV  R2,@BMR2
     002C 20D8 
0060 002E C803  38        MOV  R3,@BMR3
     0030 20DA 
0061               * Save bank containing color table in R4
0062 0032 C102  18        MOV  R2,R4
0063               * Now we're going to switch to Graphics Mode II (see 6.1.2 in VDP programmers guide
0064               * and page 267 of E/A manual). We're leaving the screen disabled for now.
0065 0034 0200  20        LI   R0,>0002
     0036 0002 
0066 0038 06A0  32        BL   @VWTR
     003A 22B6 
0067 003C 0200  20        LI   R0,>01A2 ; Screen disabled. Later we write 01E2 to enable.
     003E 01A2 
0068 0040 06A0  32        BL   @VWTR
     0042 22B6 
0069 0044 0200  20        LI   R0,>020E
     0046 020E 
0070 0048 06A0  32        BL   @VWTR
     004A 22B6 
0071 004C 0200  20        LI   R0,>03FF
     004E 03FF 
0072 0050 06A0  32        BL   @VWTR
     0052 22B6 
0073 0054 0200  20        LI   R0,>0403
     0056 0403 
0074 0058 06A0  32        BL   @VWTR
     005A 22B6 
0075 005C 0200  20        LI   R0,>0576
     005E 0576 
0076 0060 06A0  32        BL   @VWTR
     0062 22B6 
0077 0064 0200  20        LI   R0,>0603
     0066 0603 
0078 0068 06A0  32        BL   @VWTR
     006A 22B6 
0079 006C 0200  20        LI   R0,>0701 ; Backdrop color = black
     006E 0701 
0080 0070 06A0  32        BL   @VWTR
     0072 22B6 
0081               
0082               * At this point VRAM is organized in the following fashion:
0083               *
0084               * Name              Start   End
0085               * Pattern Table     >0000   >17FF
0086               * Sprite Patterns   >1800   >1FFF
0087               * Color Table       >2000   >37FF
0088               * Name Table        >3800   >3AFF
0089               * Sprite Attributes >3B00   >3BFF
0090               * Unused            >3C00   >3FFF
0091               
0092 0074 06A0  32        BL   @PLAYSNG
     0076 231A 
0093               
0094               * Load bank / file containing pattern table
0095               * Notice R1 already contains bank / file index
0096 0078 C001  18        MOV  R1,R0           ; Bank / file index in R0
0097 007A 0201  20        LI   R1,>0000        ; VDP destination in R1
     007C 0000 
0098 007E 0202  20        LI   R2,>1800        ; Number of bytes to copy in R2
     0080 1800 
0099 0082 06A0  32        BL   @LDTOVDP
     0084 2126 
0100               
0101 0086 06A0  32        BL   @PLAYSNG
     0088 231A 
0102               
0103               * Load bank / file containing color table
0104               * Notice R1 already contains bank / file index
0105 008A C004  18        MOV  R4,R0           ; Bank / file index in R0
0106 008C 0201  20        LI   R1,>2000        ; VDP destination in R1
     008E 2000 
0107 0090 0202  20        LI   R2,>1800        ; Number of bytes to copy in R2
     0092 1800 
0108 0094 06A0  32        BL   @LDTOVDP
     0096 2126 
0109               * Write the following pattern to the Name Table:
0110               * 0, 1, ..., 255, 0, 1, ..., 255, 0, 1, ..., 255
0111               * (See 8.4.1 in the VDP programmers guide)
0112 0098 0202  20        LI   R2,768   ; Length of name table
     009A 0300 
0113 009C 0200  20        LI   R0,>3800 ; Address of name table
     009E 3800 
0114 00A0 04C1  14        CLR  R1
0115 00A2 06C1  14 NTLP   SWPB R1
0116 00A4 06A0  32        BL   @VSBW
     00A6 22A0 
0117 00A8 06C1  14        SWPB R1
0118 00AA 0580  14        INC  R0
0119 00AC 0581  14        INC  R1
0120 00AE 06A0  32        BL   @PLAYSNG
     00B0 231A 
0121 00B2 0602  14        DEC  R2
0122 00B4 16F6  14        JNE  NTLP
0123               * Enable the screen
0124 00B6 0200  20        LI   R0,>01E2
     00B8 01E2 
0125 00BA 06A0  32        BL   @VWTR
     00BC 22B6 
0126               * Restore all the variables we used
0127 00BE C020  34        MOV  @BMR0,R0
     00C0 20D4 
0128 00C2 C060  34        MOV  @BMR1,R1
     00C4 20D6 
0129 00C6 C0A0  34        MOV  @BMR2,R2
     00C8 20D8 
0130 00CA C0E0  34        MOV  @BMR3,R3
     00CC 20DA 
0131 00CE C2E0  34        MOV  @BMR11,R11
     00D0 20DC 
0132 00D2 045B  20        RT
0133               
0134 00D4 0000     BMR0   DATA >0000
0135 00D6 0000     BMR1   DATA >0000
0136 00D8 0000     BMR2   DATA >0000
0137 00DA 0000     BMR3   DATA >0000
0138 00DC 0000     BMR11  DATA >0000
0139               
0140               *********************************************************************
0141               * Load To CPU RAM
0142               * If we're building a cartridge, this function switches to the bank
0143               * specified in Register 1 (0=BANK0, 1=BANK1) and copies R2 bytes to
0144               * the RAM at the address specified in Register 0. If we're loading
0145               * from disk, it copies the entire file specified in Register 1
0146               * (0=DEMOA, 1=DEMOB) to the RAM address in Register 0.
0147               *
0148               * 1. NOTICE THAT THIS TRASHES THE DATA IN THE VDP!!!
0149               * 2. DO NOT CALL THIS UNLESS YOU'VE SET LWPI >8300
0150               *
0151               * Example:
0152               *       LI  R0, 1       ; Bank 1
0153               *       LI  R1, >A000   ; To RAM address >A000
0154               *       LI  R2, >1800   ; Copy >1800 bytes
0155               *       BL  @LDTOVDP
0156               *
0157               *********************************************************************
0158                      EVEN
0159               LDTORAM
0160 00DE C80B  38        MOV  R11, @LRR11
     00E0 2124 
0161 00E2 02E0  18        LWPI  CTRLWP
     00E4 8300 
0162 00E6 C800  38        MOV  R0, @LRR0
     00E8 211C 
0163 00EA C801  38        MOV  R1, @LRR1
     00EC 211E 
0164 00EE C802  38        MOV  R2, @LRR2
     00F0 2120 
0165 00F2 C803  38        MOV  R3, @LRR3
     00F4 2122 
0166               
0179               
0180               * Load file from disk with index R0 (e.g. DEMOA, DEMOB, etc.) to address
0181               * in RAM of R1 (copy R2 bytes). NOTE: This trashes VRAM!!!
0182               
0183               * Save destination RAM address in R3 to use later
0184 00F6 C0C1  18        MOV  R1,R3
0185               * Load from file to VDP R0 = file index, R1 = >2000 (VDP dest),
0186               * R2 = # bytes to copy
0187 00F8 04C1  14        CLR  R1
0188 00FA 06A0  32        BL   @LDTOVDP
     00FC 2126 
0189               * Copy from VDP to RAM. R0 = >0000 (VDP src), R1= RAM dest, R2= # bytes to copy
0190 00FE 04C0  14        CLR  R0
0191 0100 C043  18        MOV  R3,R1
0192 0102 06A0  32        BL   @VMBR
     0104 22F2 
0193               
0195               
0196               * Restore the variables we modified
0197 0106 C020  34        MOV  @LRR0,R0
     0108 211C 
0198 010A C060  34        MOV  @LRR1,R1
     010C 211E 
0199 010E C0A0  34        MOV  @LRR2,R2
     0110 2120 
0200 0112 C0E0  34        MOV  @LRR3,R3
     0114 2122 
0201 0116 C2E0  34        MOV  @LRR11,R11
     0118 2124 
0202               
0203 011A 045B  20        RT
0204               
0205 011C 0000     LRR0   DATA >0000
0206 011E 0000     LRR1   DATA >0000
0207 0120 0000     LRR2   DATA >0000
0208 0122 0000     LRR3   DATA >0000
0209 0124 0000     LRR11  DATA >0000
0210               
0211               *********************************************************************
0212               * Load To VDP RAM
0213               * If we're building a cartridge, this function switches to the bank
0214               * specified in Register 1 (0=BANK0, 1=BANK1) and copies R2 bytes to
0215               * the VDP at the address specified in Register 0. If we're loading
0216               * from disk, it copies the entire file specified in Register 1
0217               * (0=DEMOA, 1=DEMOB) to the VDP address in Register 0.
0218               *
0219               * DO NOT CALL THIS UNLESS YOU'VE SET LWPI >8300!!
0220               *
0221               * Example:
0222               *       LI  R0, 1       ; Bank 1
0223               *       LI  R1, >2000   ; To VDP address >2000
0224               *       LI  R2, >1800   ; Copy >1800 bytes
0225               *       BL  @LDTOVDP
0226               *
0227               *********************************************************************
0228                      EVEN
0229               LDTOVDP
0230 0126 C80B  38        MOV  R11,@LVR11
     0128 21DC 
0231               
0232               * Save all the variables we're going to modify
0233 012A 02E0  18        LWPI  CTRLWP
     012C 8300 
0234               
0235 012E C800  38        MOV  R0,@LVR0
     0130 21D4 
0236 0132 C801  38        MOV  R1,@LVR1
     0134 21D6 
0237 0136 C802  38        MOV  R2,@LVR2
     0138 21D8 
0238 013A C803  38        MOV  R3,@LVR3
     013C 21DA 
0239               
0250               
0251               * Load file from disk with index R0 (e.g. DEMOA, DEMOB, etc.) to address
0252               * in VRAM of R1 (copy R2 bytes). Big thanks the Asmusr here for providing
0253               * the example code which this is based off of.
0254               
0255               * Save the destination address in VRAM to the PAB structure
0256 013E C801  38        MOV   R1,@LDADDR
     0140 21E0 
0257 0142 06A0  32        BL    @PLAYSNG
     0144 231A 
0258               * Mute all notes to prevent unpleasant noise
0259 0146 0201  20        LI    R1, MUTETB
     0148 262E 
0260 014A 0203  20        LI    R3, 4
     014C 0004 
0261 014E D831  48 ML     MOVB  *R1+, @>8400
     0150 8400 
0262 0152 0603  14        DEC   R3
0263 0154 16FC  14        JNE   ML
0264               * Clear song pointer to stop playback
0265 0156 C0E0  34        MOV   @CURSNG,R3
     0158 2370 
0266 015A 04E0  34        CLR   @CURSNG
     015C 2370 
0267               * Save the current state in a temporary slot
0268 015E 0201  20        LI    R1,STATE1
     0160 3800 
0269 0162 06A0  32        BL    @SAVEST
     0164 21F2 
0270               * Load the original machine state
0271 0166 0201  20        LI    R1,STATE0
     0168 3000 
0272 016A 06A0  32        BL    @LOADST
     016C 2260 
0273               
0274 016E 0300  24        LIMI  0
     0170 0000 
0275               * Update the file name we're loading
0276 0172 C020  34        MOV   @STATE1,R0         ; Grab index from temporary slot
     0174 3800 
0277 0176 0220  22        AI    R0,65              ; R0 + 'A'
     0178 0041 
0278 017A 06C0  14        SWPB  R0
0279 017C D800  38        MOVB  R0,@FNAME+4
     017E 21F1 
0280               * Copy PAB data into VDP RAM
0281 0180 0200  20        LI    R0,PAB
     0182 3B80 
0282 0184 0201  20        LI    R1,PABDAT
     0186 21DE 
0283 0188 0202  20        LI    R2,PABDTE-PABDAT
     018A 0014 
0284 018C 06A0  32        BL    @VMBW
     018E 22CA 
0285               * Load file
0286 0190 0200  20        LI    R0,PAB+9            ; Pointer to name length
     0192 3B89 
0287 0194 C800  38        MOV   R0,@FNPNTR          ; Store in >8356
     0196 8356 
0288 0198 0420  54        BLWP  @DSRLNK             ; Open file
     019A 23FA 
0289 019C 0008            DATA  8
0290 019E 0300  24        LIMI  0
     01A0 0000 
0291 01A2 02E0  18        LWPI  CTRLWP
     01A4 8300 
0292               * Save the original machine state
0293 01A6 0201  20        LI    R1,STATE0
     01A8 3000 
0294 01AA 06A0  32        BL    @SAVEST
     01AC 21F2 
0295               
0296               * Load the current state from the temporary slot
0297 01AE 0201  20        LI    R1,STATE1
     01B0 3800 
0298 01B2 06A0  32        BL    @LOADST
     01B4 2260 
0299 01B6 C803  38        MOV   R3,@CURSNG
     01B8 2370 
0300 01BA 06A0  32        BL    @PLAYSNG
     01BC 231A 
0301               * Restore song pointer and resume playing
0303               
0304               * Restore all the variables we modified
0305 01BE C020  34        MOV  @LVR0,R0
     01C0 21D4 
0306 01C2 C060  34        MOV  @LVR1,R1
     01C4 21D6 
0307 01C6 C0A0  34        MOV  @LVR2,R2
     01C8 21D8 
0308 01CA C0E0  34        MOV  @LVR3,R3
     01CC 21DA 
0309 01CE C2E0  34        MOV  @LVR11,R11
     01D0 21DC 
0310               
0311 01D2 045B  20        RT
0312               
0313 01D4 0000     LVR0   DATA >0000
0314 01D6 0000     LVR1   DATA >0000
0315 01D8 0000     LVR2   DATA >0000
0316 01DA 0000     LVR3   DATA >0000
0317 01DC 0000     LVR11  DATA >0000
0318               
0319               * RDFILE
0320 01DE 0500     PABDAT BYTE >05                  * I/O op-code (5=LOAD)
0321                      BYTE >00                  * Flags: n/a
0322 01E0 0000     LDADDR DATA >0000                * Data buffer address (VDP RAM)
0323 01E2 0000            DATA >0000                * Record length: n/a
0324 01E4 2100            DATA >2100                * Max bytes to read
0325 01E6 000A            DATA >000A                * File name length (including DSK1.)
0326 01E8 ....     DNAME  TEXT "DSK0."              * File device
0327 01ED ....     FNAME  TEXT "DEMOA"              * File name
0328               PABDTE
0329               
0330               *********************************************************************
0331               * Save State
0332               * Saves top >500 bytes of VRAM and scratchpad (>600 total) to address in R1.
0333               * This code expects the current workspace pointer to be >8300.
0334               *
0335               * Example:
0336               *       LI   R1, >F000
0337               *       BL   SAVEST
0338               *
0339               *********************************************************************
0340                      EVEN
0341               SAVEST
0342               * Save all the variables we're going to use
0343 01F2 C800  38        MOV  R0,@SSR0
     01F4 2256 
0344 01F6 C801  38        MOV  R1,@SSR1
     01F8 2258 
0345 01FA C802  38        MOV  R2,@SSR2
     01FC 225A 
0346 01FE C803  38        MOV  R3,@SSR3
     0200 225C 
0347 0202 C80B  38        MOV  R11,@SSR11
     0204 225E 
0348               * Save unmodified destination pointer
0349 0206 C0C1  18        MOV  R1,R3
0350               * Copy 128 words (256 bytes) from scratchpad to R1
0351 0208 0200  20        LI   R0,>8300
     020A 8300 
0352 020C 0202  20        LI   R2,256
     020E 0100 
0353 0210 CC70  46 SSLP   MOV  *R0+,*R1+
0354 0212 0642  14        DECT R2
0355 0214 16FD  14        JNE  SSLP
0356               * Save R0 - R3 the way they looked when this function started
0357 0216 C8E0  54        MOV  @SSR0,@0(R3)
     0218 2256 
     021A 0000 
0358 021C C8E0  54        MOV  @SSR1,@2(R3)
     021E 2258 
     0220 0002 
0359 0222 C8E0  54        MOV  @SSR2,@4(R3)
     0224 225A 
     0226 0004 
0360 0228 C8E0  54        MOV  @SSR3,@6(R3)
     022A 225C 
     022C 0006 
0361 022E C8E0  54        MOV  @SSR11,@22(R3)
     0230 225E 
     0232 0016 
0362               * Now copy 768 bytes from the top of the VDP to R1
0363 0234 0200  20        LI   R0,>3B00   ; Copy from >3B00 in VDP
     0236 3B00 
0364 0238 0202  20        LI   R2,>500    ; Copy >500 bytes
     023A 0500 
0365 023C 06A0  32        BL   @VMBR
     023E 22F2 
0366               * Restore the original values of all variables
0367 0240 C020  34        MOV  @SSR0,R0
     0242 2256 
0368 0244 C060  34        MOV  @SSR1,R1
     0246 2258 
0369 0248 C0A0  34        MOV  @SSR2,R2
     024A 225A 
0370 024C C0E0  34        MOV  @SSR3,R3
     024E 225C 
0371 0250 C2E0  34        MOV  @SSR11,R11
     0252 225E 
0372 0254 045B  20        RT
0373               
0374 0256 0000     SSR0   DATA >0000
0375 0258 0000     SSR1   DATA >0000
0376 025A 0000     SSR2   DATA >0000
0377 025C 0000     SSR3   DATA >0000
0378 025E 0000     SSR11  DATA >0000
0379               
0380               *********************************************************************
0381               * Load State
0382               * Loads top >500 bytes of VRAM and scratchpad (>600 total) from address in R1.
0383               * This code expects the current workspace pointer to be >8300.
0384               *
0385               * Example:
0386               *       LI   R1, >F000
0387               *       BL   LOADST
0388               *
0389               *********************************************************************
0390                      EVEN
0391               LOADST
0392               * Save all the variables we're going to need
0393 0260 C801  38        MOV  R1,@LSR1
     0262 229C 
0394 0264 C80B  38        MOV  R11,@LSR11
     0266 229E 
0395               * Copy 250 bytes from saved state to scratchpad (we don't want to
0396               * mess up R0, R1, or R2 so we'll wait and copy those at the end)
0397 0268 0200  20        LI   R0,>8306
     026A 8306 
0398 026C 0221  22        AI   R1,6
     026E 0006 
0399 0270 0202  20        LI   R2,250
     0272 00FA 
0400 0274 CC31  46 LSLP   MOV  *R1+,*R0+
0401 0276 0642  14        DECT R2
0402 0278 16FD  14        JNE  LSLP
0403               * Now copy 768 bytes from the top of the VDP to R1
0404 027A 0200  20        LI   R0,>3B00   ; Copy from >3B00 in VDP
     027C 3B00 
0405 027E 0202  20        LI   R2,>500    ; Copy >500 bytes
     0280 0500 
0406 0282 06A0  32        BL   @VMBW
     0284 22CA 
0407               * Copy R0, R1, and R2 from saved state
0408 0286 C060  34        MOV  @LSR1,R1
     0288 229C 
0409 028A C021  34        MOV  @0(R1),R0
     028C 0000 
0410 028E C0A1  34        MOV  @4(R1),R2
     0290 0004 
0411 0292 C061  34        MOV  @2(R1),R1
     0294 0002 
0412 0296 C2E0  34        MOV  @LSR11,R11
     0298 229E 
0413 029A 045B  20        RT
0414               
0415 029C 0000     LSR1   DATA >0000
0416 029E 0000     LSR11  DATA >0000
0417               
0418               *********************************************************************
0419               * VDP RAM Single Byte Write
0420               * Writes the value in the most-significant byte of Register 1 to the
0421               * VDP RAM address indicated in Register 0.
0422               * Trashes: R0
0423               *********************************************************************
0424                      EVEN
0425 02A0 0260  22 VSBW   ORI  R0,>4000
     02A2 4000 
0426 02A4 06C0  14        SWPB R0
0427 02A6 D800  38        MOVB R0,@VDPWA
     02A8 8C02 
0428 02AA 06C0  14        SWPB R0
0429 02AC D800  38        MOVB R0,@VDPWA
     02AE 8C02 
0430 02B0 D801  38        MOVB R1,@VDPWD
     02B2 8C00 
0431 02B4 045B  20        RT
0432               
0433               *********************************************************************
0434               * VDP RAM Write Register
0435               * Writes the value in the least-significant byte of Register 0 to the
0436               * VDP Register indicated in the most-significant byte of Register 0.
0437               * This is identical in behavior to the VWTR procedure in the E/A
0438               * cart.
0439               * Trashes: R0
0440               *********************************************************************
0441                      EVEN
0442 02B6 0260  22 VWTR   ORI  R0,>8000
     02B8 8000 
0443 02BA 06C0  14        SWPB R0
0444 02BC D800  38        MOVB R0,@VDPWA
     02BE 8C02 
0445 02C0 06C0  14        SWPB R0
0446 02C2 D800  38        MOVB R0,@VDPWA
     02C4 8C02 
0447 02C6 1000  14        NOP
0448 02C8 045B  20        RT
0449               
0450               *********************************************************************
0451               * VDP RAM Multibyte Write
0452               * Writes the array at Register 1 to the VDP RAM location in Register
0453               * 0. Writes Register 2 bytes.
0454               * Trashes: R0, R1, R2
0455               *********************************************************************
0456                      EVEN
0457 02CA C80B  38 VMBW   MOV  R11,@MBWS11
     02CC 22F0 
0458 02CE 06C0  14        SWPB R0
0459 02D0 D800  38        MOVB R0,@VDPWA
     02D2 8C02 
0460 02D4 06C0  14        SWPB R0
0461 02D6 0260  22        ORI  R0,>4000
     02D8 4000 
0462 02DA D800  38        MOVB R0,@VDPWA
     02DC 8C02 
0463 02DE D831  48 MBWLP  MOVB *R1+,@VDPWD
     02E0 8C00 
0464 02E2 06A0  32        BL   @PLAYSNG
     02E4 231A 
0465 02E6 0602  14        DEC  R2
0466 02E8 16FA  14        JNE  MBWLP
0467 02EA C2E0  34        MOV  @MBWS11,R11
     02EC 22F0 
0468 02EE 045B  20        RT
0469 02F0 0000     MBWS11 DATA >0000
0470               
0471               *********************************************************************
0472               * VDP RAM Multibyte Read
0473               * Reads R2 bytes from VDP Ram at address R0 to system RAM at address
0474               * contained in R1.
0475               * Trashes: R0, R1, R2
0476               *********************************************************************
0477                      EVEN
0478 02F2 C80B  38 VMBR   MOV  R11,@MBRS11
     02F4 2318 
0479 02F6 06C0  14        SWPB R0
0480 02F8 D800  38        MOVB R0, @VDPWA
     02FA 8C02 
0481 02FC 06C0  14        SWPB R0
0482 02FE 0240  22        ANDI R0, >3FFF
     0300 3FFF 
0483 0302 D800  38        MOVB R0, @VDPWA
     0304 8C02 
0484 0306 DC60  48 MBRLP  MOVB @VDPRD, *R1+
     0308 8800 
0485 030A 06A0  32        BL   @PLAYSNG
     030C 231A 
0486 030E 0602  14        DEC  R2
0487 0310 16FA  14        JNE  MBRLP
0488 0312 C2E0  34        MOV @MBRS11,R11
     0314 2318 
0489 0316 045B  20        RT
0490 0318 0000     MBRS11 DATA >0000
0491               
0492               *********************************************************************
0493               * Play Song
0494               * Plays the currently loaded song in a loop. If @VDPINT is zero on exit,
0495               * then we bailed because we haven't hit a VDP interrupt yet.
0496               *********************************************************************
0497               PLAYSNG
0498               * If we're not currently on the vblank then quit
0499 031A 04E0  34        CLR  @VDPINT
     031C 2372 
0500               
0501 031E C80C  38        MOV  R12, @SAVR12
     0320 2374 
0502               
0503 0322 04CC  14        CLR  R12
0504 0324 1F02  20        TB   2                          ; Test CRU bit for VDP interrupt
0505 0326 1320  14        JEQ  BYE2                       ; This is supposedly more reliable than polling the status
0506               
0507 0328 C801  38        MOV  R1, @SAVR1
     032A 2376 
0508 032C C802  38        MOV  R2, @SAVR2
     032E 2378 
0509 0330 C80B  38        MOV  R11, @SAVR11
     0332 237A 
0510               
0511 0334 D820  54        MOVB @VDPSTA, @VDPINT
     0336 8802 
     0338 2372 
0512 033A 05A0  34        INC  @TIME
     033C 236E 
0513               
0514               * If no song is loaded, then quit
0515 033E C320  34        MOV  @CURSNG, R12
     0340 2370 
0516 0342 130C  14        JEQ  BYE
0517               
0518               * Play the song
0519 0344 06A0  32        BL   @STPLAY
     0346 2644 
0520 0348 02E0  18        LWPI CTRLWP
     034A 8300 
0521               
0522               * Check for song end
0523 034C D320  34        MOVB @SONGWP+14, R12
     034E 832E 
0524 0350 1605  14        JNE  BYE
0525               
0526               * Play again
0527 0352 04C2  14        CLR  R2
0528 0354 C060  34        MOV  @CURSNG,R1
     0356 2370 
0529 0358 06A0  32        BL   @STINIT
     035A 2598 
0530               
0531               * Cleanup
0532               BYE
0533 035C C060  34        MOV  @SAVR1, R1
     035E 2376 
0534 0360 C0A0  34        MOV  @SAVR2, R2
     0362 2378 
0535 0364 C2E0  34        MOV  @SAVR11, R11
     0366 237A 
0536               BYE2
0537 0368 C320  34        MOV  @SAVR12, R12
     036A 2374 
0538 036C 045B  20        RT
0539               
0540 036E 0000     TIME   DATA >0000
0541 0370 0000     CURSNG DATA >0000
0542 0372 0000     VDPINT DATA >0000
0543 0374 0000     SAVR12 DATA >0000
0544 0376 0000     SAVR1  DATA >0000
0545 0378 0000     SAVR2  DATA >0000
0546 037A 0000     SAVR11 DATA >0000
0547               
0548               ********************************************************************************
0549               * Set max number of open files (by asmusr)
0550               * R0: Max number of open files
0551               ********************************************************************************
0553 037C C80B  38 FILES   MOV  R11,@FSAVR11        * Push return address onto the stack
     037E 23B2 
0554 0380 C800  38 	    MOV	 R0,@NFILES          * Save #files argument
     0382 23AE 
0555 0384 0200  20 	    LI   R0,PAB
     0386 3B80 
0556 0388 0201  20         LI   R1,PDATA
     038A 23B0 
0557 038C 0202  20         LI   R2,2
     038E 0002 
0558 0390 06A0  32         BL	 @VMBW               * Copy 2 bytes from PDATA (RAM) to PAB (VRAM)
     0392 22CA 
0559 0394 0200  20 	    LI   R0,PAB
     0396 3B80 
0560 0398 C800  38         MOV  R0,@>8356           * Point to subroutine in DSR
     039A 8356 
0561 039C D820  54         MOVB @NFILES+1,@>834C    * #files argument for subroutine 016h
     039E 23AF 
     03A0 834C 
0562 03A2 0420  54         BLWP @DSRLNK             * Call DSR with subprogram option
     03A4 23FA 
0563 03A6 000A             DATA 10
0564               *	    Return
0565 03A8 C2E0  34 	    MOV  @FSAVR11,R11
     03AA 23B2 
0566 03AC 045B  20 	    B	*R11
0567               
0568 03AE 0001     NFILES  DATA >0001               * Number of simultaneous files
0569 03B0 0116     PDATA   DATA >0116               * DSR subprogram to run (FILES)
0570 03B2 0000     FSAVR11 DATA >0000
0571               
0572               * Disk access routines
0573                      COPY "gpllnk.a99"
**** **** ****     > gpllnk.a99
0001               * GPLLNK
0002               * Based on code published in The Smart Programmer, issue 07/1986
0003               * Copyright (c) 1985, 1986 by Miller Graphics
0004               
0005               gpllnk_ws_r4:
0006                      equ  GPLWP + 8
0007               gpllnk_ws_r6:
0008                      equ  GPLWP + 12
0009               
0010               gpllnk_stkpnt:
0011                      equ  >8373
0012               
0013               gpllnk_ldgadd:
0014                      equ  >60
0015               gpllnk_xtab27:
0016                      equ  >200e
0017               gpllnk_getstk:
0018                      equ  >166c
0019               
0020               gpllnk:
0021 03B4 23A6            data gpllnk_ws, gpllnk_main
     03B6 23C6 
0022               gpllnk_rtnad:
0023 03B8 23EA            data gpllnk_xmlrtn
0024               gpllnk_gxmlad:
0025 03BA 176C            data >176c
0026 03BC 0050            data >50
0027               
0028               gpllnk_ws:
0029                      equ  $->18
0030 03BE ....            bss  >08
0031               
0032               gpllnk_main:
0033 03C6 C81B  46        mov  *r11, @gpllnk_ws_r4
     03C8 83E8 
0034 03CA C83E  50        mov  *r14+, @gpllnk_ws_r6
     03CC 83EC 
0035 03CE C320  34        mov  @gpllnk_xtab27, r12
     03D0 200E 
0036 03D2 C809  38        mov  r9, @gpllnk_xtab27
     03D4 200E 
0037 03D6 02E0  18        lwpi GPLWP
     03D8 83E0 
0038 03DA 0694  24        bl   *r4
0039 03DC C920  54        mov  @gpllnk_gxmlad, @>8302(r4)
     03DE 23BA 
     03E0 8302 
0040 03E2 05E0  34        inct @gpllnk_stkpnt
     03E4 8373 
0041 03E6 0460  28        b    @gpllnk_ldgadd
     03E8 0060 
0042               
0043               gpllnk_xmlrtn:
0044 03EA C120  34        mov  @gpllnk_getstk, r4
     03EC 166C 
0045 03EE 0694  24        bl   *r4
0046 03F0 02E0  18        lwpi gpllnk_ws
     03F2 23A6 
0047 03F4 C80C  38        mov  r12, @gpllnk_xtab27
     03F6 200E 
0048               
0049 03F8 0380  18        rtwp
**** **** ****     > controller.a99
0574                      COPY "dsrlnk.a99"
**** **** ****     > dsrlnk.a99
0001               * DSRLNK
0002               * Based on code published in The Smart Programmer, issue 07/1986
0003               * Copyright (c) 1985, 1986 by Miller Graphics
0004               * NOTE: Code is self-modifying and cannot run in cartridge space.
0005               
0006               dsrlnk_type:
0007                      equ  >836d
0008               dsrlnk_namelen:
0009                      equ  >8356
0010               dsrlnk_gstat:
0011                      equ  >837c
0012               dsrlnk_putstk:
0013                      equ  >50
0014               gplws_4lb:
0015                      equ  >83e9
0016               
0017               dsrlnk:
0018 03FA 23FE            data dsrlnk_ws, dsrlnk_main
     03FC 23FE 
0019               
0020               dsrlnk_ws:
0021                      equ  $
0022               dsrlnk_ws_3lb:
0023                      equ  dsrlnk_ws + 7
0024               
0025               dsrlnk_main:
0026 03FE C30C  18        mov  r12, r12
0027 0400 161C  14        jne  dsrlnk_redux
0028               
0029 0402 02E0  18        lwpi GPLWP
     0404 83E0 
0030 0406 C120  34        mov  @dsrlnk_putstk, r4
     0408 0050 
0031 040A 0694  24        bl   *r4
0032 040C 0204  20        li   r4, >11
     040E 0011 
0033 0410 DB44  38        movb r4, @>402(r13)
     0412 0402 
0034 0414 1004  14        jmp  !
0035 0416 0000            data 0, 0, 0, 0
     0418 0000 
     041A 0000 
     041C 0000 
0036 041E DB60  54 !      movb @gplws_4lb, @>402(r13)
     0420 83E9 
     0422 0402 
0037 0424 C160  34        mov  @gpllnk_getstk, r5
     0426 166C 
0038 0428 D81D  46        movb *r13, @dsrlnk_alb
     042A 244D 
0039 042C 05E0  34        inct @dsrlnk_ahb
     042E 244C 
0040 0430 0695  24        bl   *r5
0041 0432 02E0  18        lwpi dsrlnk_ws
     0434 23FE 
0042 0436 020C  20        li   r12, >2000
     0438 2000 
0043               
0044               dsrlnk_redux:
0045 043A 058E  14        inc  r14
0046 043C D83E  48        movb *r14+, @dsrlnk_type
     043E 836D 
0047 0440 C0E0  34        mov  @dsrlnk_namelen, r3
     0442 8356 
0048 0444 0223  22        ai   r3, -8
     0446 FFF8 
0049 0448 0420  54        blwp @gpllnk
     044A 23B4 
0050               dsrlnk_ahb:
0051 044C 0300            byte >03
0052               dsrlnk_alb:
0053                      byte >00
0054               
0055 044E D820  54        movb @dsrlnk_ws_3lb, @vdpwa
     0450 2405 
     0452 8C02 
0056 0454 D803  38        movb r3, @vdpwa
     0456 8C02 
0057 0458 53CC  18        szcb r12, r15
0058 045A D0E0  34        movb @vdpwd, r3
     045C 8C00 
0059 045E 0953  56        srl  r3, 5
0060 0460 D743  30        movb r3, *r13
0061 0462 1603  14        jne  !
0062 0464 2320  38        coc  @dsrlnk_gstat, r12
     0466 837C 
0063 0468 1601  14        jne  dsrlnk_done
0064 046A F3CC  18 !      socb r12, r15
0065               
0066               dsrlnk_done:
0067 046C 0380  18        rtwp
**** **** ****     > controller.a99
0576               
0577               * Copy player code
0578                      COPY "tiplayer30hz.a99"
**** **** ****     > tiplayer30hz.a99
0001               * 30hz music-only player
0002               * 2014 by Tursi aka Mike Brent
0003               * Released to public domain, may be used freely
0004               
0005               * uses 126 bytes of RAM plus 32 bytes for a temporary workspace (158 total)
0006               * 620 bytes of code
0007               
0008               * cycle counting an average song gives a range of about 1000-10000 cycles per frame, with an
0009               * average of 2000 cycles. That's 333uS - 3333uS, average of 666uS. One scanline (out of 262)
0010               * is about 63.666uS, so the decompression takes from 5-52 scanlines, average of 10 scanlines.
0011               * That means about 2%-20% of the CPU, with an average of 4%, at 60Hz playback.
0012               
0013               * externally visible data (on return):
0014               * R7 (songwp+14) contains >FFFF if the song is still playing, and >0000 if it's done
0015               * R9-R10 (songwp+18-20) contains one byte for each voice's current volume
0016               * R12-R15 (songwp+24-30) contain the current frequency word (last channel is just a noise nibble)
0017               
0018               * R0 = return data, scratch       R8 = scratch
0019               * R1 = scratch                    R9 = user volume bytes 0-1
0020               * R2 = scratch                    R10= user volume bytes 2-3
0021               * R3 = stream base for fctn       R11= subroutine return
0022               * R4 = voice counter (0-3)        R12= voice 0 frequency
0023               * R5 = stream base pointer        R13= voice 1 frequency
0024               * R6 = time counter pointer       R14= voice 2 frequency
0025               * R7 = still playing flag         R15= noise type
0026               
0027               * this one ported to work with the gcc assembler,  and export data
0028               	def stinit30
0029               	def ststop30
0030               	def stplay30
0031               
0032               * these are just intended to be read from the map file so they can be used for timing
0033               	def timingin30
0034               	def timingout30
0035               
0036               * helpful for finding the variable for volume attenuation
0037               	def atten
0038               
0039               * must point to a workspace that the player can corrupt at will,
0040               * however,  the memory is not needed between calls
0041               * C runtime uses >8300, and >8320 is used to store 0s for my own hack
0042               * songwp equ >8322
0043               
0044               	dseg
0045               
0046               		even
0047               * pointers,  in order streampos,  streamref,  streamcnt, streambase, repeated 12 times (for decompression)
0048 046E ....     strm	bss 96
0049               * time countdown for each of 4 channels (bytes)
0050 04CE ....     tmcnt	bss 4
0051               * count of override for timestreams (bytes)
0052 04D2 ....     tmocnt	bss 4
0053               * type of override for timestreams (bytes)
0054 04D6 ....     tmovr	bss 4
0055               * pointer to the song data (needed for offset fixups)
0056 04DA ....     songad	bss 2
0057               * pointer to the frequency table (used for speedup)
0058 04DC ....     freqad	bss 2
0059               * return address
0060 04DE ....     retad	bss 2
0061               * frame flag (a bit wasteful but time efficient - you can also
0062               * use the non-30Hz version and just call it at 30hz ;) )
0063 04E0 ....     frflag	bss 2
0064               * global attenuation (in MSB, 0 (no attenuation), f (max attenuation))
0065               * defaults to 0 on every stinit!
0066 04E2 ....     atten bss 2
0067               
0068               	pseg
0069               * get a compressed byte from a stream - stream data base in r3
0070               * byte is return in r0 msb
0071               * uses r1, r2
0072               	even
0073               getbyte
0074 04E4 C063  34 	mov @2(r3), r1				* test streamref
     04E6 0002 
0075 04E8 130C  14 	jeq getb1					* not set
0076 04EA 0281  22 	ci r1,>ffff				* test for repeat count
     04EC FFFF 
0077 04EE 1310  14 	jeq getb1noinc			* not backref
0078 04F0 D031  28 	movb *r1+, r0				* get back-referenced byte
0079 04F2 C8C1  38 	mov r1, @2(r3)				* write new value back
     04F4 0002 
0080 04F6 0623  34 	dec @4(r3)					* decrement counter
     04F8 0004 
0081 04FA 1602  14 	jne getb2					* not 0 yet
0082 04FC 04E3  34 	clr @2(r3)					* out of bytes,  clear back reference ptr
     04FE 0002 
0083               getb2
0084 0500 045B  20 	b *r11						* and return
0085               
0086               getb1
0087               * get byte with increment - need to pre-test for 0, so the jnc
0088 0502 0623  34 	dec @4(r3)					* count down
     0504 0004 
0089 0506 170D  14 	jnc getb3						* we went negative, so it must have been 0
0090               
0091               getb1inc
0092 0508 C053  26 	mov *r3, r1					* get stream pointer
0093 050A D031  28 	movb *r1+, r0				* get byte from current run
0094 050C C4C1  30 	mov r1, *r3					* write new value back
0095 050E 045B  20 	b *r11						* and return
0096               
0097               * get byte with no increment - need to pre-test for 0, so the jnc
0098               getb1noinc
0099 0510 0623  34 	dec @4(r3)				* count down
     0512 0004 
0100 0514 1706  14 	jnc getb3					* it went negative, so must have been 0
0101 0516 13F8  14 	jeq getb1inc			* increment always on last byte
0102               
0103 0518 C053  26 	mov *r3, r1				* get stream pointer
0104 051A D011  26 	movb *r1, r0			* get byte from current run
0105 051C 045B  20 	b *r11						* and return
0106               
0107               nostream
0108 051E D002  18 	movb r2,r0					* return (r2 is expected to be zero!)
0109 0520 045B  20 	b *R11
0110               
0111               getb3
0112               * count is zero, need to get a new command
0113 0522 C053  26 	mov *r3, r1					* get pointer to stream
0114 0524 04C2  14 	clr r2						* prepare r2
0115 0526 D0B1  28 	movb *r1+, r2				* get new count byte
0116 0528 13FA  14 	jeq nostream				* was a zero
0117 052A 151F  14 	jgt getb4					* if high bit is clear (no 0x80)
0118               
0119 052C 20A0  38 	coc @dat40,r2				* check for 40 (indicates 2 byte reference)
     052E 2634 
0120 0530 130C  14 	jeq getb3double
0121               
0122               * get single byte back reference
0123 0532 0242  22 	andi r2, >3f00				* mask it
     0534 3F00 
0124 0536 06C2  14 	swpb r2						* store in the lsbyte
0125 0538 0602  14 	dec r2						* we are going to consume one byte below,  and we know it's at least 4
0126 053A C8C2  38 	mov r2, @4(r3)				* write it to count
     053C 0004 
0127 053E 04C2  14 	clr r2						* prepare msb
0128 0540 D0B1  28 	movb *r1+, r2				* get backref pointer
0129 0542 06C2  14 	swpb r2						* put in correct order
0130 0544 A0A3  34 	a @6(r3),r2					* add stream base, r2 now has the correct address
     0546 0006 
0131 0548 100B  14 	jmp getb3fin
0132               
0133               getb3double
0134 054A 0242  22 	andi r2, >3f00				* mask it
     054C 3F00 
0135 054E 06C2  14 	swpb r2						* store in the lsbyte
0136 0550 0602  14 	dec r2						* we are going to consume one byte below,  and we know it's at least 4
0137 0552 C8C2  38 	mov r2, @4(r3)				* write it back
     0554 0004 
0138 0556 D0B1  28 	movb *r1+, r2			* the absolute address saves 2 swpb's for 2 bytes code and 8 cycles
0139 0558 D831  48 	movb *r1+, @songwp+5	* get backref pointer (can't use mov,  might be misaligned, r2 LSB)
     055A 8325 
0140 055C A0A0  34 	a @songad, r2				* make into a pointer
     055E 24DA 
0141               
0142               getb3fin
0143 0560 D032  28 	movb *r2+, r0				* get back-referenced byte
0144 0562 C8C2  38 	mov r2, @2(r3)				* and store back reference pointer
     0564 0002 
0145 0566 C4C1  30 	mov r1, *r3					* and save stream pointer
0146 0568 045B  20 	b *r11						* and return
0147               
0148               getb4
0149               * 0x80 is not set, check for just 0x40
0150 056A 20A0  38 	coc @dat40, r2
     056C 2634 
0151 056E 1309  14 	jeq getb5					* it's set, so go process that
0152               
0153               * neither bit is set, so it's just a plain run
0154 0570 06C2  14 	swpb r2						* fix byte order (assumes no corruption,  lsbyte is already zero)
0155 0572 D031  28 	movb *r1+, r0				* get byte from current run
0156 0574 0602  14 	dec r2						* count down - no need to test here
0157 0576 C8C2  38 	mov r2, @4(r3)				* save count
     0578 0004 
0158 057A C4C1  30 	mov r1, *r3					* save pointer
0159 057C 04E3  34 	clr @2(r3)				* make sure the streamref is zeroed (needed for the 0xffff case)
     057E 0002 
0160 0580 045B  20 	b *r11						* and return
0161               
0162               getb5
0163               * 0x40 is set - set up for a repeated character
0164 0582 0242  22 	andi r2, >3f00				* mask it
     0584 3F00 
0165 0586 06C2  14 	swpb r2						* put in the correct byte
0166 0588 0602  14 	dec r2						* count down the one we are going to take
0167 058A C8C2  38 	mov r2,@4(r3)				* save the result
     058C 0004 
0168 058E D011  26 	movb *r1, r0				* get the appropriate byte - note no increment!
0169 0590 C4C1  30 	mov r1,*r3				* save it (necessary because we incremented way above)
0170 0592 0723  34 	seto @2(r3)					* set the reference to 0xffff
     0594 0002 
0171 0596 045B  20 	b *r11						* and return
0172               
0173               
0174               * start a new tune,  with the pointer to the module in r1, and index of tune in r2 (usually 0)
0175               stinit
0176 0598 C801  38 	mov r1,@songwp		* save the address in our workspace's R0
     059A 8320 
0177 059C C802  38 	mov r2,@songwp+6	* save the index in our workspace's R3
     059E 8326 
0178 05A0 02E0  18 	lwpi songwp
     05A2 8320 
0179 05A4 C800  38 	mov r0, @songad		* save it for later
     05A6 24DA 
0180 05A8 05C0  14 	inct r0						* point to the frequency table
0181 05AA C050  26 	mov *r0,r1				* get the pointer
0182 05AC 0640  14 	dect r0						* back to the base
0183 05AE A040  18 	a r0,r1						* make a real pointer
0184 05B0 C801  38 	mov r1,@freqad		* and remember it
     05B2 24DC 
0185 05B4 0201  20 	li r1, 12
     05B6 000C 
0186 05B8 0202  20 	li r2, strm
     05BA 246E 
0187 05BC C010  26 	mov *r0, r0			* point to the table of pointers
0188 05BE 0204  20 	li r4,24			* 24 bytes per table
     05C0 0018 
0189 05C2 3903  56 	mpy r3,r4			* get the offset to the requested stream table (into r4,r5)
0190 05C4 A005  18 	a r5,r0				* add it in
0191 05C6 A020  34 	a @songad, r0		* make a memory pointer
     05C8 24DA 
0192               sti1
0193 05CA C4B0  42 	mov *r0+, *r2		* get stream offset
0194 05CC A4A0  46 	a @songad, *r2		* make it a pointer - when all four voices point to zero,  the tune is over
     05CE 24DA 
0195 05D0 C892  46 	mov *r2,@6(r2)		* copy into stream base pointer
     05D2 0006 
0196 05D4 05C2  14 	inct r2
0197 05D6 04F2  30 	clr *r2+			* clear reference
0198 05D8 04F2  30 	clr *r2+			* clear count
0199 05DA 05C2  14 	inct r2				* skip stream base pointer
0200 05DC 0601  14 	dec r1
0201 05DE 16F5  14 	jne sti1
0202               
0203 05E0 04F2  30 	clr *r2+			* clear four byte time counters
0204 05E2 04F2  30 	clr *r2+
0205               
0206 05E4 04F2  30 	clr *r2+			* clear four byte timer override counters
0207 05E6 04F2  30 	clr *r2+
0208               
0209               * put sanish values in the user feedback registers
0210 05E8 0707  14 	seto r7				* playing flag
0211 05EA 0709  14 	seto r9				* volume bytes
0212 05EC 070A  14 	seto r10
0213 05EE 04CC  14 	clr r12				* tone words
0214 05F0 04CD  14 	clr r13
0215 05F2 04CE  14 	clr r14
0216 05F4 04CF  14 	clr r15
0217               
0218 05F6 04E0  34 	clr @frflag			* clear frame flag - important!
     05F8 24E0 
0219 05FA 04E0  34 	clr @atten			* maximum volume
     05FC 24E2 
0220               
0221 05FE 02E0  18 	lwpi >8300			* c workspace
     0600 8300 
0222 0602 045B  20 	b *r11				* back to caller
0223               
0224               * call to stop the tune or initialize to silence
0225               * uses r0, r1
0226               ststop
0227 0604 02E0  18 	lwpi songwp
     0606 8320 
0228               
0229 0608 0201  20 	li r1, 52			* 12*4 + 4
     060A 0034 
0230 060C 0200  20 	li r0, strm
     060E 246E 
0231               sts1
0232 0610 04F0  30 	clr *r0+			* get stream offset
0233 0612 0601  14 	dec r1
0234 0614 16FD  14 	jne sts1
0235               
0236 0616 04C7  14 	clr r7				* clear playing flag
0237               
0238               * modified from original source to mute all channels (thanks asmusr) - orby
0239 0618 0200  20     li r0,mutetb
     061A 262E 
0240 061C 0202  20     li r2,4
     061E 0004 
0241               mtesn1
0242 0620 D830  48     movb *r0+,@>8400
     0622 8400 
0243 0624 0602  14     dec r2
0244 0626 16FC  14     jne mtesn1
0245               * end modification
0246               
0247 0628 02E0  18 	lwpi >8300			* c workspace
     062A 8300 
0248 062C 045B  20 	b *r11				* back to caller
0249               
0250               mutetb
0251 062E 9FBF         byte >9f,>bf,>df,>ff
     0630 DFFF 
0252               
0253 0632 8000     dat80	data >8000
0254 0634 4000     dat40	data >4000
0255 0636 0100     dat01	data >0100
0256 0638 80A0     tonemk	data >80a0, >c0e0
     063A C0E0 
0257 063C 90B0     volmk	data >90b0, >d0f0
     063E D0F0 
0258 0640 4142     specdt	data >4142, >4300
     0642 4300 
0259               
0260               * call every vblank to update the music
0261               * intended to be called from vblank hook - returns with
0262               * the workspace changed to songwp
0263               stplay
0264               timingin30
0265 0644 0560  34 	inv @frflag			* invert - so it must have started as 0 or 0xffff, or we'll always run!
     0646 24E0 
0266 0648 1601  14 	jne run4real
0267 064A 045B  20 	b *r11
0268               
0269               ** temp hack - measuring time **
0270               *	li r0, >0487
0271               *	movb r0, @>8c02
0272               *	swpb r0
0273               *	movb r0, @>8c02
0274               *********************************
0275               run4real
0276 064C C80B  38 	mov r11, @retad		* save return address
     064E 24DE 
0277 0650 02E0  18 	lwpi songwp			* get 'our' workspace
     0652 8320 
0278               
0279 0654 04C7  14 	clr r7				* flag for caller - if 0,  the song is over (songwp+14)
0280               
0281 0656 0204  20 	li r4, 3					* counter for 4 voices
     0658 0003 
0282 065A 0205  20 	li r5, strm+24		* pointing to last stream object
     065C 2486 
0283 065E 0206  20 	li r6, tmcnt+3		* pointing to last time counter
     0660 24D1 
0284               
0285               stpl1
0286 0662 C025  34 	mov @64(r5), r0		* test time stream pointer (stream 8,  8 bytes per stream,  8*8)
     0664 0040 
0287 0666 1375  14 	jeq stpl2			* skip if empty
0288               
0289 0668 0707  14 	seto r7				* found valid data,  flag for caller
0290               
0291 066A 75A0  46 	sb @dat01,*r6	* decrement timer
     066C 2636 
0292 066E 1871  14 	joc stpl2			* was not zero,  next loop (this will catch 0 -> -1, as desired)
0293               
0294               stplx1
0295 0670 C0C5  18 	mov r5, r3
0296 0672 0223  22 	ai r3, 64					* pointer to time stream (stream 8)
     0674 0040 
0297               
0298 0676 D026  34 	movb @4(r6),r0		* tmocnt
     0678 0004 
0299 067A 1306  14 	jeq stplx2				* no override active
0300               
0301 067C 79A0  54 	sb @dat01,@4(r6)	* tmocnt (count down)
     067E 2636 
     0680 0004 
0302 0682 D226  34 	movb @8(r6),r8		* tmovr - get the override byte
     0684 0008 
0303 0686 102B  14 	jmp postld				* jump ahead to process
0304               
0305               stplx2
0306 0688 06A0  32 	bl @getbyte			* get a compressed byte
     068A 24E4 
0307 068C D000  18 	movb r0, r0			* test the result
0308 068E 1602  14 	jne stpl3			* was not zero
0309               
0310 0690 04D3  26 	clr *r3				* zero the timestream pointer
0311 0692 105F  14 	jmp stpl2			* next loop
0312               
0313               stpl3
0314 0694 04C8  14 	clr r8
0315 0696 D200  18 	movb r0, r8			* save the command
0316               
0317 0698 0288  22 	ci r8,>7a00			* test for special range
     069A 7A00 
0318 069C 1A20  14 	jl stlp3b
0319 069E 1318  14 	jeq stshrt
0320 06A0 0288  22 	ci r8,>7f00
     06A2 7F00 
0321 06A4 1B1C  14 	jh stlp3b
0322               
0323 06A6 0288  22 	ci r8,>7d00
     06A8 7D00 
0324 06AA 1A09  14 	jl stborc
0325               
0326 06AC 0228  22 	ai r8,->7c00
     06AE 8400 
0327 06B0 D988  38 	movb r8,@4(r6)		* tmocnt
     06B2 0004 
0328               
0329 06B4 D220  34 	movb @specdt,r8		* was 0x7d,0x7e,0x7f
     06B6 2640 
0330 06B8 D988  38 	movb r8,@8(r6)		* tmovr
     06BA 0008 
0331 06BC 1010  14 	jmp postld
0332               
0333               stborc
0334 06BE 0228  22 	ai r8,->7a00
     06C0 8600 
0335 06C2 D988  38 	movb r8,@4(r6)		* tmocnt
     06C4 0004 
0336               
0337 06C6 D220  34 	movb @specdt+1,r8	* was 0x7b or 0x7c
     06C8 2641 
0338 06CA D988  38 	movb r8,@8(r6)		* tmovr
     06CC 0008 
0339 06CE 1007  14 	jmp postld
0340               
0341               stshrt
0342 06D0 D9A0  54 	movb @dat01,@4(r6)	* tmocnt
     06D2 2636 
     06D4 0004 
0343 06D6 D220  34 	movb @specdt+2,r8		* was a 0x7a
     06D8 2642 
0344 06DA D988  38 	movb r8,@8(r6)			* tmovr
     06DC 0008 
0345               
0346               postld
0347               * r8 now has tmovr
0348               
0349               stlp3b
0350 06DE 2220  38 	coc @dat80, r8		* check for tone
     06E0 2632 
0351 06E2 161D  14 	jne stpl4			* not set,  skip
0352               
0353 06E4 C0C5  18 	mov r5, r3			* base stream is tones
0354 06E6 04C0  14 	clr r0				* prepare for tone index (not needed if noise)
0355 06E8 06A0  32 	bl @getbyte			* get it
     06EA 24E4 
0356               
0357 06EC 0284  22 	ci r4, 3			* check for noise channel
     06EE 0003 
0358 06F0 1606  14 	jne sttone
0359               
0360               *noise channel
0361 06F2 0260  22 	ori r0,>e000			* or in the sound command nibble (we know we are on channel 3, save some code+time)
     06F4 E000 
0362 06F6 D800  38 	movb r0, @>8400		* move to the sound chip
     06F8 8400 
0363 06FA 06C0  14 	swpb r0				* swap data so we can save it off
0364 06FC 100C  14 	jmp stpl4a
0365               
0366               sttone
0367 06FE 06C0  14 	swpb r0				* get into correct byte
0368 0700 0A10  56 	sla r0,1			* make index
0369 0702 A020  34 	a @freqad,r0	* make pointer
     0704 24DC 
0370 0706 C010  26 	mov *r0, r0			* get the frequency data
0371 0708 F024  34 	socb @tonemk(r4), r0	* or in the sound command nibble
     070A 2638 
0372 070C D800  38 	movb r0, @>8400		* move to the sound chip
     070E 8400 
0373 0710 06C0  14 	swpb r0				* swap data so we can save it off
0374 0712 D800  38 	movb r0, @>8400		* move the second byte
     0714 8400 
0375               
0376               stpl4a
0377 0716 0A14  56 	sla r4,1			* make an index
0378 0718 C900  38 	mov r0,@songwp+24(r4)	* save it (r12->r15)
     071A 8338 
0379 071C 0914  56 	srl r4,1			* change it back
0380               
0381               stpl4
0382 071E 2220  38 	coc @dat40, r8		* check for volume
     0720 2634 
0383 0722 1612  14 	jne stpl5
0384               
0385 0724 C0C5  18 	mov r5, r3
0386 0726 0223  22 	ai r3, 32				* 4 streams up,  4*8
     0728 0020 
0387 072A 06A0  32 	bl @getbyte			* get it
     072C 24E4 
0388 072E B020  34 	ab @atten,r0    * add global volume attenuation 30
     0730 24E2 
0389 0732 0280  22 	ci r0,>1000     * can we get around this?
     0734 1000 
0390 0736 1A02  14 	jl stvl         * it's okay
0391 0738 0200  20 	li r0,>0f00     * clamp to silence
     073A 0F00 
0392               stvl
0393 073C F024  34 	socb @volmk(r4), r0	* or in the sound command nibble
     073E 263C 
0394 0740 D800  38 	movb r0, @>8400		* move to the sound chip
     0742 8400 
0395 0744 D900  38 	movb r0, @songwp+18(r4)	* save it off (r9->r10)
     0746 8332 
0396               
0397               stpl5
0398 0748 0248  22 	andi r8, >3f00		* mask off the count
     074A 3F00 
0399 074C 7220  34 	sb @dat01,r8			* decement for this tick
     074E 2636 
0400 0750 D588  30 	movb r8,*r6				* save it off
0401               
0402               stpl2
0403 0752 0225  22 	ai r5, -8					* next stream struct
     0754 FFF8 
0404 0756 0606  14 	dec r6						* next timer
0405 0758 0604  14 	dec r4						* next loop
0406 075A 1883  14 	joc stpl1					* not done yet
0407               
0408               ** temp hack - measuring time **
0409               *	li r0, >0287
0410               *	movb r0, @>8c02
0411               *	swpb r0
0412               *	movb r0, @>8c02
0413               *********************************
0414               
0415 075C C2E0  34 	mov @retad, r11		* get return address back
     075E 24DE 
0416               
0417               timingout30
0418 0760 045B  20 	b *r11				* now done 1 tick
**** **** ****     > controller.a99
0579               
0580               *********************************************************************
0581               * DO NOT CHANGE ANYTHING ABOVE HERE WITHOUT UPDATING THE HARDCODED
0582               * FUNCTION POINTERS IN .\SRC\COMMON\ROUTINES.INC!
0583               *********************************************************************
0584               
0585               *********************************************************************
0586               * Main control code
0587               *********************************************************************
0588               CTRL
0589               * Disable all interrupts
0590 0762 0300  24        LIMI 0
     0764 0000 
0591               
0592               * If we're loading from disk, copy the disk name over
0593               * Code copied more or less verbatim from:
0594               * 1.7. The Art Of Assembly Part 7. Why A Duck?
0595               * By Bruce Harrison 1991
0596               * Thanks to Asmusr for hooking me up with this.
0598 0766 C320  34        MOV    @>83D0,R12           * GET THE CRU BASE IN R12
     0768 83D0 
0599 076A C260  34        MOV    @>83D2,R9            * GET THE ROM ADDRESS FOR DEVICE
     076C 83D2 
0600 076E 1D00  20        SBO    0                    * ENABLE THE ROM
0601 0770 0229  22        AI     R9,4                 * ADDING FOUR PUTS US AT THE LENGTH BYTE
     0772 0004 
0602 0774 D139  28        MOVB   *R9+,R4              * PLACE THAT IN R4 AND INCREMENT R9
0603 0776 0984  56        SRL    R4,8                 * RIGHT JUSTIFY LENGTH IN R4
0604 0778 020A  20        LI     R10,DNAME            * POINT TO TEXT BUFFER
     077A 21E8 
0605 077C DEB9  42 MOVIT  MOVB   *R9+,*R10+           * MOV ONE BYTE FROM ROM TO TEXT BUFFER
0606 077E 0604  14        DEC    R4                   * FINISHED?
0607 0780 16FD  14        JNE    MOVIT                * NO, DO ANOTHER BYTE
0608 0782 1E00  20        SBZ    0                    * DISABLE THE ROM
0610               
0611               * If we're loading from disk, reduce the number of simultaneous files to 1
0613 0784 0200  20        LI   R0, 1
     0786 0001 
0614 0788 06A0  32        BL   @FILES
     078A 237C 
0616               
0617               * Save the original state of the machine before we go messing around
0618 078C 0201  20        LI   R1,STATE0
     078E 3000 
0619 0790 06A0  32        BL   @SAVEST
     0792 21F2 
0620               
0621 0794 0206  20        LI   R6,SCNLST       ; Scene list pointer
     0796 2892 
0622 0798 04C7  14        CLR  R7              ; Current song bank/index
0623 079A 04C8  14        CLR  R8              ;
0624               
0625               * Enter main loop
0626               LOOP
0627               * Blank screen
0628 079C 0200  20        LI   R0, >01A1
     079E 01A1 
0629 07A0 06A0  32        BL   @VWTR
     07A2 22B6 
0630               
0631               * Load effect into high area memory at >A000 (we have 20K to work with)
0632 07A4 C036  30        MOV  *R6+,R0         ; Copy bank / file index for effect to R0
0633 07A6 0201  20        LI   R1,FXMEM        ; RAM destination in R1
     07A8 A000 
0634 07AA 0202  20        LI   R2,>2000        ; Number of bytes to copy in R2
     07AC 2000 
0635 07AE 06A0  32        BL   @LDTORAM        ; Copy from bank / file index R0 to RAM at R1
     07B0 20DE 
0636               
0637               * Don't load if we're playing the same song
0638 07B2 81D6  26        C    *R6,R7
0639 07B4 1316  14        JEQ  NOLDMSX
0640               
0641 07B6 C1D6  26        MOV  *R6,R7          ; Save current song indices
0642 07B8 06A0  32        BL   @STSTOP         ; Stop the music
     07BA 2604 
0643               
0644               * Load song into high area memory at >F000 (we have 4K to work with)
0645               
0646 07BC D036  28        MOVB *R6+,R0         ; Bank / file index in R0 (song list ptr is in R6)
0647 07BE D0F6  28        MOVB *R6+,R3         ; Song index in R5
0648 07C0 0980  56        SRL  R0,8            ; Shift high byte down
0649 07C2 0973  56        SRL  R3,7            ; Low byte of R3 = song index * 2
0650               
0651 07C4 04E0  34        CLR  @CURSNG
     07C6 2370 
0652 07C8 0201  20        LI   R1,SONGMEM      ; RAM destination in R1
     07CA F000 
0653 07CC 0202  20        LI   R2,>1000        ; Number of bytes to copy in R2
     07CE 1000 
0654 07D0 06A0  32        BL   @LDTORAM        ; Copy from bank / file index R0 to RAM at R1
     07D2 20DE 
0655               
0656 07D4 04C2  14        CLR  R2              ; only one tune
0657 07D6 C063  34        MOV  @SONGMEM(R3),R1 ; Address of VGM song
     07D8 F000 
0658 07DA C201  18        MOV  R1,R8
0659 07DC 06A0  32        BL   @STINIT         ; Initialize song player
     07DE 2598 
0660 07E0 1001  14        JMP  NOINC
0661               
0662               NOLDMSX
0663 07E2 05C6  14        INCT R6
0664               
0665               NOINC
0666 07E4 C060  34        MOV  @FXMEM+2,R1     ; Pointer to effect frame renderer
     07E6 A002 
0667 07E8 04C2  14        CLR  R2              ; Clear render loop counter
0668 07EA 04E0  34        CLR  @TIME           ; Reset time
     07EC 236E 
0669 07EE 06A0  32        BL   @SVWP
     07F0 284E 
0670 07F2 C020  34        MOV  @FXMEM+0,R0     ; Pointer to effect initialization
     07F4 A000 
0671 07F6 0690  24        BL   *R0             ; Initialize effect
0672 07F8 06A0  32        BL   @LDWP
     07FA 2860 
0673 07FC C808  38        MOV  R8,@CURSNG
     07FE 2370 
0674               
0675               RENDER                      ; Render frames until the effect says stop
0676               
0677 0800 06A0  32 VSYNC  BL   @PLAYSNG        ; Play music
     0802 231A 
0678 0804 C020  34        MOV  @VDPINT,R0
     0806 2372 
0679 0808 13FB  14        JEQ  VSYNC
0680               
0681               * Fast keyboard scan routine. Skip to next effect when spacebar is pressed.
0682               * Ripped from http://www.unige.ch/medecine/nouspikel/ti99/tutor1.htm
0683               
0684 080A 020D  20        LI   R13,>0000       ; keyboard column 0
     080C 0000 
0685 080E 020C  20        LI   R12,>0024       ; CRU address of the decoder
     0810 0024 
0686 0812 30CD  56        LDCR R13,3           ; select the column
0687 0814 020C  20        LI   R12,>0006       ; address of the first row
     0816 0006 
0688 0818 360E  64        STCR R14,8           ; read 8 rows
0689 081A C34E  18        MOV  R14,R13         ; make a copy
0690 081C 024E  22        ANDI R14,>0200       ; test spacebar
     081E 0200 
0691 0820 130E  14        JEQ  SKIPFX          ; pressed
0692 0822 024D  22        ANDI R13,>1100       ; test quit
     0824 1100 
0693 0826 130F  14        JEQ  QUIT
0694               
0695 0828 C0E0  34        MOV  @TIME,R3        ; Copy frame counter over
     082A 236E 
0696 082C 06A0  32        BL   @SVWP
     082E 284E 
0697 0830 0691  24        BL   *R1             ; Render frame
0698 0832 06A0  32        BL   @LDWP
     0834 2860 
0699 0836 0582  14        INC  R2
0700 0838 0280  22        CI   R0,>0000        ; If R0!=0, then bail on render loop
     083A 0000 
0701 083C 13E1  14        JEQ  RENDER
0702               
0703               SKIPFX
0704 083E C116  26        MOV  *R6,R4
0705 0840 0284  22        CI   R4,>0000        ; If next effect is zero, then bail
     0842 0000 
0706 0844 16AB  14        JNE  LOOP
0707               
0708 0846 04E0  34 QUIT   CLR  @>83C4          ; Reset user ISR address
     0848 83C4 
0709 084A 0420  54        BLWP @>0000          ; Reboot
     084C 0000 
0710               
0711 084E 0200  20 SVWP   LI   R0, WPBU+2
     0850 2874 
0712 0852 CC01  34        MOV  R1, *R0+
0713 0854 CC02  34        MOV  R2, *R0+
0714 0856 CC03  34        MOV  R3, *R0+
0715               *       MOV  R4, *R0+
0716               *       MOV  R5, *R0+
0717 0858 CC06  34        MOV  R6, *R0+
0718 085A CC07  34        MOV  R7, *R0+
0719 085C CC08  34        MOV  R8, *R0+
0720               *       MOV  R9, *R0+
0721               *       MOV  R10, *R0+
0722               *       INCT R0
0723               *       MOV  R12, *R0+
0724               *       MOV  R13, *R0+
0725               *       MOV  R14, *R0+
0726               *       MOV  R15, *R0+
0727 085E 045B  20        B    *R11
0728               
0729 0860 020F  20 LDWP   LI   R15,WPBU+2
     0862 2874 
0730 0864 C07F  30        MOV  *R15+, R1
0731 0866 C0BF  30        MOV  *R15+, R2
0732 0868 C0FF  30        MOV  *R15+, R3
0733               *       MOV  *R15+, R4
0734               *       MOV  *R15+, R5
0735 086A C1BF  30        MOV  *R15+, R6
0736 086C C1FF  30        MOV  *R15+, R7
0737 086E C23F  30        MOV  *R15+, R8
0738               *       MOV  *R15+, R9
0739               *       MOV  *R15+, R10
0740               *       INCT R15
0741               *       MOV  *R15+, R12
0742               *       MOV  *R15+, R13
0743               *       MOV  *R15+, R14
0744               *       MOV  *R15+, R15
0745 0870 045B  20        B    *R11
0746               
0747 0872 0000     WPBU    DATA >0000, >0000, >0000, >0000, >0000, >0000, >0000, >0000
     0874 0000 
     0876 0000 
     0878 0000 
     087A 0000 
     087C 0000 
     087E 0000 
     0880 0000 
0748 0882 0000             DATA >0000, >0000, >0000, >0000, >0000, >0000, >0000, >0000
     0884 0000 
     0886 0000 
     0888 0000 
     088A 0000 
     088C 0000 
     088E 0000 
     0890 0000 
0749               *********************************************************************
0750               * Scene List
0751               *
0752               * This is a list of effects and songs that will be played in the
0753               * order they are provided.
0754               *
0755               * The first word is a bank / file index of an effect. The high byte of the
0756               * second word is the bank / file index of a song bank. The low byte of the
0757               * second word is the index of the song within the song bank.
0758               * See ./src/effects/music/songbank1.a99 for an example of a song bank.
0759               *********************************************************************
0760                      EVEN
0761               SCNLST
0762 0892 0010            DATA >0010, >0500  ; Bank 16: Checkerboard zoom                 Mode 1
     0894 0500 
0763               
0764 0896 001E            DATA >001E, >0500  ; Bank 30: Don't mess with Texas (image)     Mode 2
     0898 0500 
0765 089A 000F            DATA >000F, >0500  ; Bank 15: Sine scroller                     Mode 1
     089C 0500 
0766 089E 0019            DATA >0019, >0500  ; Bank 25: Spinning box animation (decoder)  Mode 2 hybrid
     08A0 0500 
0767 08A2 0016            DATA >0016, >0500  ; Bank 22: Infinite dots                     Mode 1
     08A4 0500 
0768 08A6 0015            DATA >0015, >0500  ; Bank 21: Multicolor rotozoom               Mode 3
     08A8 0500 
0769 08AA 0011            DATA >0011, >0500  ; Bank 17: Infinite bobs                     Mode 2
     08AC 0500 
0770 08AE 000A            DATA >000A, >0500  ; Bank 10: Boing ball                        Mode 2
     08B0 0500 
0771 08B2 0010            DATA >0010, >0500  ; Bank 16: Checkerboard zoom                 Mode 1
     08B4 0500 
0772               
0773 08B6 000E            DATA >000E, >0500  ; Bank 14: Multiplane                        Mode 1
     08B8 0500 
0774 08BA 0009            DATA >0009, >0501  ; Bank 9: Metaballs                          Mode 1
     08BC 0501 
0775 08BE 0008            DATA >0008, >0501  ; Bank 8: Square tunnel                      Mode 1
     08C0 0501 
0776 08C2 0006            DATA >0006, >0501  ; Bank 6: Raycaster                          Mode 2
     08C4 0501 
0777 08C6 0003            DATA >0003, >0500  ; Bank 3: Dot fx                             Mode 2 hybrid
     08C8 0500 
0778 08CA 0004            DATA >0004, >0500  ; Bank 4: Lena image                         Mode 2
     08CC 0500 
0779               *      DATA >0003, >0500  ; Bank 3: Dot fx
0780               *      DATA >0004, >0501  ; Bank 4: Lena (image)
0781               
0782 08CE 000C            DATA >000C, >0500  ; Bank 12: Twister and scroller              Mode 2 hybrid
     08D0 0500 
0783 08D2 0012            DATA >0012, >0500  ; Bank 18: Sine wave splitscreen             Mode 1
     08D4 0500 
0784 08D6 0017            DATA >0017, >0500  ; Bank 23: Multisplit                        Mode 1/2/3
     08D8 0500 
0785 08DA 0013            DATA >0013, >0500  ; Bank 19: Splitscreen 3D scroller           Mode 1
     08DC 0500 
0786 08DE 001F            DATA >001F, >2000  ; Bank 31: Credits scroller                  Mode 1
     08E0 2000 
0787 08E2 0000            DATA >0000, >0000  ; Zero signifies reboot
     08E4 0000 
0788                      END
