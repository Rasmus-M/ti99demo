* DSRLNK
* Based on code published in The Smart Programmer, issue 07/1986
* Copyright (c) 1985, 1986 by Miller Graphics
* NOTE: Code is self-modifying and cannot run in cartridge space.
* NOTE2: This code requires the standard 99/4A console ROM

dsrlnk_type:
       equ  >836d
dsrlnk_namelen:
       equ  >8356
dsrlnk_gstat:
       equ  >837c
dsrlnk_putstk:
       equ  >50
gplws_4lb:
       equ  >83e9

dsrlnk:
       data dsrlnk_ws, dsrlnk_main

dsrlnk_ws:
       equ  $
dsrlnk_ws_3lb:
       equ  dsrlnk_ws + 7

* the workspace overlays this code -
* you must never use R0 or R1, and after
* the first call, the rest of this block is
* considered destroyed. (In particular the
* LWPI is messed up...)
dsrlnk_main:
       mov  r12, r12                ; test if R12 is set
       jne  dsrlnk_redux            ; if so, skip the next block

* This entire block is just to get the address in GROM of the
* GROM-based DSRLNK function
       lwpi GPLWP                   ; get GPL workspace
       mov  @dsrlnk_putstk, r4      ; ROM function to save GROM address
       bl   *r4                     ; save GROM address on GPL stack
       li   r4, >11									; GPL DSRLNK branch address in GROM
       movb r4, @>402(r13)          ; write MSB of GROM address
       jmp  !                       ; skip important register space
       data 0, 0, 0, 0              ; R12 - R15 - CRU and BLWP space
!      movb @gplws_4lb, @>402(r13)  ; write LSB of GROM address
       mov  @gpllnk_getstk, r5      ; ROM function to restore GROM address
       movb *r13, @dsrlnk_alb       ; get low byte address of GPL DSRLNK (We assume >03xx)
       inct @dsrlnk_ahb             ; skip over a fetch command (BASIC)
       bl   *r5                     ; restore GROM address from GPL stack
       lwpi dsrlnk_ws               ; back to our workspace
       li   r12, >2000              ; set R12 with top of CRU space

dsrlnk_redux:
       inc  r14                     ; reading the post BLWP DATA, skip MSB
       movb *r14+, @dsrlnk_type     ; get the desired type of call
       mov  @dsrlnk_namelen, r3
       ai   r3, -8
       blwp @gpllnk
dsrlnk_ahb:
       byte >03
dsrlnk_alb:
       byte >00

       movb @dsrlnk_ws_3lb, @vdpwa
       movb r3, @vdpwa
       szcb r12, r15
       movb @vdpwd, r3
       srl  r3, 5
       movb r3, *r13
       jne  !
       coc  @dsrlnk_gstat, r12
       jne  dsrlnk_done
!      socb r12, r15

dsrlnk_done:
       rtwp
       


